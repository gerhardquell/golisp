# Session 4 – Unix-Style CLI

**Datum:** 2026-02-25
**Autoren:** Gerhard Quell & Claude Sonnet 4.6

---

## Was haben wir gebaut?

| Feature | Dateien | Commits |
|---------|---------|---------|
| Unix-Style CLI mit Flags | `main.go` | 1 |
| Stdin-Modus (Default) | `main.go` | 1 |
| Expression-Flag `-e` | `main.go` | 1 |
| Interaktiver Modus `-i` | `main.go` | 1 |
| Exit-Codes 0/1 | `main.go` | 1 |
| Multiline-Support für Stdin | `main.go` | 1 |
| Dokumentation in CLAUDE.md | `CLAUDE.md` | 1 |
| Dokumentation in README.md | `README.md` | 1 |

**Gesamt:** 6 Features, 5 Commits, ~120 neue Zeilen Go-Code.

**Vorher:** `./golisp` startete direkt den REPL, keine Pipe-Unterstützung, keine Exit-Codes.
**Nachher:** Vollständiges Unix-Tool mit konsistentem Interface für Scripts und Systemintegration.

---

## Was lief gut?

### Klare Trennung der Modi
Die Umkehrung der Logik (Default = stdin statt REPL) macht GoLisp sofort nützlicher für Shell-Scripts. Die fünf Modi sind orthogonal:

| Modus | Verwendung |
|-------|------------|
| `echo "expr" \| golisp` | Einzeiler in Scripts |
| `golisp -e "expr"` | Direkte Ausführung ohne Pipe |
| `golisp -i` | Expliziter interaktiver Modus |
| `golisp script.lisp` | Datei laden |
| `golisp -t` | Test-Suite |

### Multiline-Support für Stdin
Der `countParens`-Algorithmus berücksichtigt Strings und Escapes korrekt:

```go
// Offene Klammern zählen, aber String-Inhalte ignorieren
if ch == '\\' && inString { escape = true; continue }
if ch == '"' && !escape { inString = !inString }
```

Das erlaubt komplexe Eingaben via Pipe:

```bash
cat <<'EOF' | ./golisp
(defun square (x)
  (* x x))
(square 5)
EOF
# => 25
```

### Konsistente Exit-Codes
- **0** = Erfolg (alle Ausdrücke evaluiert, kein Fehler)
- **1** = Fehler (Parser-Fehler, Eval-Fehler, unbalancierte Klammern)

Das ist essentiell für Shell-Scripts:

```bash
if echo "(+ 1 2)" | ./golisp > /dev/null; then
    echo "GoLisp funktioniert"
fi
```

### TTY-Erkennung für `-i`
Der REPL prüft vor dem Start ob stdin ein Terminal ist:

```go
if !isTerminal(int(os.Stdin.Fd())) {
    fmt.Fprintln(os.Stderr, "ERR: Interactive mode requires a TTY")
    return 1
}
```

Das verhindert verwirrende Fehler wenn man versehentlich `echo "..." | ./golisp -i` tippt.

---

## Was lief nicht so gut?

### Keine nennenswerten Probleme
Alle Modi funktionierten auf Anhieb:
- Build erfolgreich
- Alle 40 Tests grün
- Pipe-Modus, Expression-Flag, REPL, Datei-Loading, Exit-Codes – alles wie spezifiziert

---

## Technische Erkenntnisse

### Unix-Philosophie
Ein Tool sollte eine Sache gut machen und sich wie andere Tools verhalten:
- Lesen von stdin (Default)
- Schreiben nach stdout (Ergebnisse)
- Fehler nach stderr
- Exit-Code signalisiert Erfolg/Misserfolg

### Go's flag-Package
Die Standardbibliothek `flag` ist ausreichend für CLI-Tools:

```go
interactiveFlag := flag.Bool("i", false, "Interaktiver REPL-Modus")
exprFlag := flag.String("e", "", "Expression direkt ausführen")
testFlag := flag.Bool("t", false, "Tests ausführen")
```

Keine externe Dependency nötig.

### TTY-Erkennung via ioctl
```go
_, _, err := syscall.Syscall6(syscall.SYS_IOCTL, uintptr(fd), syscall.TCGETS, ...)
```

Dies ist der portable Linux-Weg – funktioniert auf allen gängigen Terminals.

---

## Fazit Session 4

GoLisp ist jetzt ein erstklassiges Unix-Citizen. Die CLI-Transformation
verwandelt den Interpreter von einem interaktiven Spielzeug in ein
produktives Werkzeug für die Kommandozeile.

> "Ein Werkzeug das sich wie Unix anfühlt,
>  wird Teil von Unix."
> — Gerhard & Claude, Februar 2026
