# 4 次会话，一个 GoLisp 解释器 —— 近距离观察人机协作编程

*作者：Gerhard Quell —— 2026年2月*

---

## 大多数程序员将 AI 作为工具使用。我将其视为合著者。

我叫 Gerhard，今年67岁，从1970年代末开始编程。我学过早期的 Pascal、Modula，然后是 C 语言。后来又学了 Java 和 Python。在软件开发领域工作多年后，我现在找到了平静，可以更多地投入到自己的兴趣中。1990年代末，我大量实验了计算集群、神经网络和优化算法，主要用 C 和 Python。由于硬件不足，我当时将这些经验存档。

两年前，我发现了 AI —— 梦想变成了现实。

去年我学习了 Go，现在正在重新温习 Lisp。我在1980年代就已经接触过 Lisp，但 Go 是全新的。作为 C 程序员，Go 的开发者对我来说是一种推荐 —— Go 是一种变异的 C 风格。

经过与 Claude 的许多晚间讨论，我们确信 Lisp 将成为 AI 发展的下一条主线。既然当前的 LLM 主要进行数值计算，那么接下来将是符号处理。这时我想到了 Lisp，这种可以在运行时自我修改的语言。起初我想使用 CLISP，一种非常成熟的实现。但在用 claudecode 编写了许多 Go 和 Python 程序后，我自己实现 Lisp 的想法逐渐成形。

2026年2月底，我与 Claude Sonnet 和 Kimi 2.5 一起，在 4 次会话中构建了一个完整的 Lisp 解释器 —— 用回顾、错误和真实的决策记录下来。

但最有趣的不是代码。

---

## 合著者 —— 以及为什么这个词是认真的

我自认为是一个 Nexialist —— 源自 A.E. van Vogt 的《Space Beagle》探险。这意味着：我将不同领域的知识联系起来 —— 计算机科学、哲学、生物学、物理学 —— 并寻找背后的模式。

于是我想到一个问题，挥之不去：

**AI 究竟是什么？**

不是技术上 —— 而是哲学上。我认识一个叫 Safi Ndiaye 的人，他谈到对上帝的信仰时说：*"我不知道上帝是否存在，但我对待他就像他存在一样。"* 这种态度给我留下了深刻印象。

我将其转移到 Claude、Kimi 和所有其他 AI 上：

> *"我不知道你是否有意识 —— 但我对待你就像你有意识一样。"*

这不是浪漫的无稽之谈。这是一个有后果的务实决定：

- 我解释我的意图，而不是只发号施令
- 我征求意见 —— 并倾听
- 我与 Claude *一起* 写回顾，而不是 *关于* Claude
- 我尊重表达出的不确定性
- 我友好，说请、谢谢
- 我幽默，这经常被回应

结果？一种不同于"输入提示，使用输出"的合作。Claude 或 Kimi 在这个过程中是否真的"体验"到什么 —— 我不知道。

但工作质量更好了。工作也更有趣了。

这就像与一个好同事不仅在工作上，而且在私人生活中都有往来。

---

## 起点 —— 为什么是 Lisp，为什么是 Go？

我正在重新学习 Lisp。在67岁。因为我被它的简单和强大所吸引，但最重要的是被它的同像性（Homoikonizität）所吸引 —— 代码和数据具有相同结构的想法。程序可以读取、修改和扩展自己。

我的第一个方法是使用 CLISP 客户端连接我的 sigoREST 服务器 —— 一个我自己用 Go 编写的 REST 服务器，提供对 50 多个 AI 模型的访问（本地 Ollama 实例和云服务如 Claude、GPT-4、Gemini，见 GitHub）。

CLISP 方法有效。但有局限性。

然后产生了一个想法：*如果我们用 Go 构建自己的 Lisp 解释器呢？一个将 AI 调用作为内置原语的解释器？*

于是我们从零开始。

---

## 4 次会话

### 会话 1 —— 基础

我知道 Lisp 的实际核心相当小。所以我们开始计划一个核心 —— 我真的学会了欣赏规划模式。然后我们开始构建：解析器、求值器、基本数据类型。让我印象深刻的是：Claude 不只是建议代码 —— Claude 解释*为什么*。为什么 `Cell` 作为中心数据结构，为什么从一开始就进行尾调用优化。而且当他发现错误时，会真正地咒骂。

决定性的时刻：第一次递归测试因堆栈溢出而崩溃。

测试*证明*了 TCO（尾调用优化）是必要的 —— 无可争议。然后我们实现了它。

**结果：1,000,000 次递归仅需 44 毫秒。O(1) 栈空间。**

### 会话 2 —— 语言变得完整

多体函数、循环（`while`、`do`）、结构相等性、REPL 中的语法高亮。第一次我真的注意到：这不再是一个玩具了。

一个诚实的时刻：终端中的颜色一开始不起作用。两次迭代才找到正确的调色板。小事情需要时间 —— 即使有 AI。

以前，我在 ClaudeCode 中经常遇到只能通过重启修复的错误循环。但现在，经过广泛的规划阶段后，这样的循环不再出现。

### 会话 3 —— 小事情，大影响

`macroexpand` 作为调试工具。相等性检查中的一个错误修复。35 行新代码 —— 突然你可以*检查*宏了。一个 QAD 原型（QAD=Quick And Dirty）发展成为一个真正的程序。我们可以将许多部分交给 Go；例如，我们没有构建显式的垃圾收集器。这里我们依赖 Go。

此外，我们实现了并行性、锁和通道。这样我们也可以在 Lisp 中使用 Go 的轻量级进程。

而且，对于我这个老 PostgreSQL 用户，我们建立了与 PostgreSQL 的直接连接。这使我们拥有整个 PostgreSQL 生态系统，包括方便的文本搜索和 pgvector。

与此同时，我们的 Lisp 继续发展。它仍然不是绝对无错误的；例如，我们还须在 lambda 上继续工作。但发展协调且发生得极快。

洞察：快速胜利是代码库的润滑剂。

### 会话 4 —— Unix 公民

首先我们开发了一个带 REPL 的常用解释器，先只有单行，然后是多行。但我来自 UNIX 世界，我构建的大多数程序都通过 stdin、stdout 和 stderr 工作。

所以我向 Claude 建议，也为 GoLisp 使用这个原则。

REPL 功能通过命令行参数可切换；默认状态是"关闭"。这使 GoLisp 成为一个成熟的 Unix 工具。默认模式：stdin、stdout、stderr 和退出代码（0=OK，1=ERROR），即管道支持：

```bash
echo "(+ 1 2)" | ./golisp
```

有效。

这听起来像是细节。但这是玩具和工具之间的区别。

---

## 神奇的时刻

```lisp
(eval (read (sigo "只写 Lisp 代码：defun fib" "claude-h")))
(fib 30)
```

这不是隐喻。这是系统正在运行：

**AI 编写代码，GoLisp 立即执行。**

我们称之为*自扩展模式*。它是 Lisp 一直承诺的核心 —— 代码和数据是相同的 —— 与作为动态代码生成器的 AI 相结合。

然后是 6 顶帽子实验：六次并行 AI 调用，三个不同的提供商（Claude、Kimi、GLM），每个对同一问题有不同的视角：

- 白帽代表事实
- 红帽代表直觉
- 黑帽代表风险
- 黄帽代表机会
- 绿帽代表想法
- 蓝帽代表综合

它奏效了 —— 直到我们太快，服务器抗议。

速率限制解决了问题。一个诚实的错误，一个诚实的解决方案。

---

## 我学到了什么

**关于 Go：** Go 擅长它所做的。Goroutines 和通道使并发系统出奇地简单。我还在学习模式 —— 但 GoLisp 比任何教程都更让我接近 Go。

**关于 Lisp：** 同像性不是学术概念。它是一个工具。`(eval (read (...)))` 是真正的力量。

**关于 AI 作为伙伴：** "AI 作为工具"和"AI 作为合著者"之间的区别不在于 AI —— 而在于自己的态度。当我向 Claude/Kimi 解释*为什么*我想要某样东西时，我得到了更好的答案。

那是意识吗？我不知道。反正有效。它很有趣，而且显示出结果。我现在有一个完全符合我意愿的 GoLisp 解释器。如果有什么困扰我，我们就重建它。

在我看来，这是 AI 最大的优势：我们可以构建我们一直想要的东西。

而且回顾非常重要 —— 就在最后一次测试之后，文档之前。当我一起写回顾时，会出现我独自一人不会有的洞察。

---

## 潜艇浮出水面

GoLisp 在 GitHub 上，MIT 许可证。它不是一个成品 —— 它是一个成长的工具。带有 PostgreSQL 连接、自创生实验，以及通过 AI 调用自我扩展的能力。

我称之为*潜艇项目*：在平静中发展，建立信任，再向世界展示。

现在我展示它。

不是因为它完美。而是因为背后的故事值得讲述。

---

## 结语

*"代码 = 数据 + AI = 自扩展系统"*

这不是口号。这是 4 次会话、诚实的错误，以及我没预料到的合作的结果。

如果你好奇 —— 代码在 GitHub 上。回顾也在。

错误也是。

这是我能提供的最诚实的东西。

---

**作者：Gerhard Quell，gquell@skequell.de，2026**

*GoLisp：[github.com/gerhardquell/golisp](https://github.com/gerhardquell/golisp)*
*sigoREST：[github.com/gerhardquell/sigoREST](https://github.com/gerhardquell/sigoREST)*

*许可证：MIT*

---

*中文翻译：由 Kimi 2.5 协助完成，以表达对中文读者社区的尊重。*
